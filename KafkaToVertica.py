from pymongo import MongoClient
import json
from pprint import pprint
import kafka
from kafka import KafkaConsumer
import vertica_python
from vertica_python import connect
import logging

program = 'consumer_kakfa_vertica'
kafkabroker = '<kafkabroktername>'
kafkabrokerport = 9092
kafkatopic = '<kafkatopic>''
verticahost = '<targetverticahost>'
verticausername='<verticauser>'
verticapassword='<verticapass>'
targettable='<targettable>'

'''
# Maxwell process at source captures data change events. This program currently caonverts json payload and filters the inserts events
and insert in to vertica table.  
1. Reading from kafka.
2. transform json object to required field.
3. converting cdc this operations in insert statements to write to vertica.
'''
#logging.basicConfig(filename='consumer_kakfa_vertica.log',filemode='w',level=logging.INFO)
FORMAT = '%(asctime)s  %(message)s'
logging.basicConfig(filename='consumer_kakfa_vertica.log',filemode='w',format=FORMAT, level=logging.INFO)
# logging.basicConfig(format='%(asctime)s - %(message)s', level=logging.INFO)


''' kafka settings'''

consumer1 = KafkaConsumer(bootstrap_servers=['{}:{}'.format(kafkabroker,kafkabrokerport)],
                         auto_offset_reset='LATEST',
                         group_id='python_consumer_vertica_1')
consumer1.subscribe([kafkatopic])

''' Vertica Connection Info '''
conn_info = {'host': verticahost,
             'port': 5433,
             'user': verticausername,
             'password': verticapassword,
             # 'database': 'nodocker',
             # autogenerated session label by default,
             # 'session_label': 'some_label',
             # 10 minutes timeout on queries
             'read_timeout': 600,
             # default throw error on invalid UTF-8 results
             'unicode_error': 'strict',
             # SSL is disabled by default
             'ssl': False,
             # using server-side prepared statements is disabled by default
             'use_prepared_statements': False,
             # connection timeout is not enabled by default
             'connection_timeout': 5}

while 1 == 1:

    ''' testing first 200 messages '''
    messages_processing = []
    counter = 1
    maxcounter = 200
    for messages in consumer1:
        counter = counter+1
    #     print(counter)
    #   pprint(messages.value)
    #   pprint(type(messages.value.decode("utf-8")))
        messages_processing.append(json.loads(messages.value.decode("utf-8")))
        if counter == maxcounter:
            break

    # pprint(messages_processing)


    # filtering insert messages
    messages_processing_ins = []

    for message_raw in messages_processing:
         if message_raw['type'] == 'insert' and message_raw['table'] == targettable:
            messages_processing_ins.append(message_raw)

    # pprint(messages_processing_ins)



    # # simple connection, with manual close
    def insert_vertica(sql):
        connection = vertica_python.connect(**conn_info)
        cur = connection.cursor()
        cur.execute(sql)
        cur.execute("commit")

    def fatch_vertica(database,table):
        connection = vertica_python.connect(**conn_info)
        cur = connection.cursor()
        sql = "select * from {}.{}".format(database,table)
        print(sql)
        cur.execute(sql)
        for row in cur.fetchall():
            pprint(row)


    # extracting columns
    columns_l = []
    values_l = []
    columns_s = ''
    values_s = ''
    for message in messages_processing_ins:
    #     pprint(message)
        columns_l = []
        values_l = []
        columns_s = ''
        values_s = ''
        columns_l = ([key for key in message['data'].keys()])
        values_l = ([val for val in message['data'].values()])
        sql1 = "INSERT INTO {}.{} ({}) VALUES ({});".format(message['database'],message['table'],str(columns_l).strip('[]').replace("'",
""),str(values_l).strip('[]'))
        print ("Inserting following sql\n")
        print (sql1)
        insert_vertica(sql1)
        vcolumns_l = []
        values_l = []
        columns_s = ''
        values_s = ''

    fatch_vertica(message['database'],message['table'])

    # pprint(columns_l)
    # pprint(values_l)
